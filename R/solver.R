# Multi-Depot Vehicle Routing Problem with Time Windows and Heterogeneous Fleet
# Solver Algorithms
# Author: AI Assistant

library(dplyr)

#' Main solver function for MDVRPTWH
#' 
#' @param problem A problem instance generated by generate_problem_instance
#' @param method Solving method ("nn", "greedy", "sa")
#' @param max_iterations Maximum number of iterations for metaheuristics
#' 
#' @return A solution object with routes and cost information
#' @export
solve_mdvrptwh <- function(problem, method = "nn", max_iterations = 1000) {
  start_time <- Sys.time()
  
  # Validate problem instance
  validation <- validate_problem_instance(problem)
  if (!validation$valid) {
    return(list(
      status = "ERROR",
      message = paste("Invalid problem instance:", paste(validation$errors, collapse = "; ")),
      routes = NULL,
      cost = Inf,
      solve_time = as.numeric(Sys.time() - start_time, units = "secs")
    ))
  }
  
  # Solve based on method
  solution <- switch(method,
    "nn" = solve_nearest_neighbor(problem),
    "greedy" = solve_greedy(problem),
    "sa" = solve_simulated_annealing(problem, max_iterations),
    stop("Unknown solving method: ", method)
  )
  
  # Calculate total cost and validate solution
  solution$cost <- calculate_total_cost(problem, solution$routes)
  solution$solve_time <- as.numeric(Sys.time() - start_time, units = "secs")
  solution$status <- if (validate_solution(problem, solution)) "OPTIMAL" else "INFEASIBLE"
  solution$method <- method
  
  return(solution)
}

#' Nearest Neighbor Algorithm
#' 
#' @param problem A problem instance
#' 
#' @return A solution with routes
solve_nearest_neighbor <- function(problem) {
  routes <- list()
  unvisited_customers <- 1:nrow(problem$customers)
  
  for (v in 1:nrow(problem$vehicles)) {
    vehicle <- problem$vehicles[v, ]
    depot_idx <- vehicle$depot_id
    current_location <- depot_idx  # Start at depot
    current_time <- 0
    current_capacity <- vehicle$capacity
    route <- list(
      vehicle_id = vehicle$vehicle_id,
      depot_id = vehicle$depot_id,
      sequence = c(depot_idx),
      arrival_times = c(0),
      service_times = c(0),
      total_distance = 0,
      total_time = 0,
      load = 0
    )
    
    while (length(unvisited_customers) > 0 && current_capacity > 0) {
      # Find nearest feasible customer
      best_customer <- NULL
      best_distance <- Inf
      
      for (cust_idx in unvisited_customers) {
        customer <- problem$customers[cust_idx, ]
        
        # Check capacity constraint
        if (customer$demand > current_capacity) next
        
        # Calculate distance from current location to customer
        distance <- get_distance(problem, current_location, cust_idx + nrow(problem$depots))
        travel_time <- distance / vehicle$speed
        arrival_time <- current_time + travel_time
        
        # Check time window constraint
        if (arrival_time > customer$late_time) next
        
        if (distance < best_distance) {
          best_distance <- distance
          best_customer <- cust_idx
        }
      }
      
      if (is.null(best_customer)) break
      
      # Visit the best customer
      customer <- problem$customers[best_customer, ]
      customer_location_idx <- best_customer + nrow(problem$depots)
      
      distance <- get_distance(problem, current_location, customer_location_idx)
      travel_time <- distance / vehicle$speed
      arrival_time <- current_time + travel_time
      service_start_time <- max(arrival_time, customer$early_time)
      departure_time <- service_start_time + customer$service_time
      
      route$sequence <- c(route$sequence, customer_location_idx)
      route$arrival_times <- c(route$arrival_times, arrival_time)
      route$service_times <- c(route$service_times, service_start_time)
      route$total_distance <- route$total_distance + distance
      route$total_time <- departure_time
      route$load <- route$load + customer$demand
      
      current_location <- customer_location_idx
      current_time <- departure_time
      current_capacity <- current_capacity - customer$demand
      unvisited_customers <- unvisited_customers[unvisited_customers != best_customer]
    }
    
    # Return to depot
    if (length(route$sequence) > 1) {
      return_distance <- get_distance(problem, current_location, depot_idx)
      route$total_distance <- route$total_distance + return_distance
      route$total_time <- current_time + return_distance / vehicle$speed
      route$sequence <- c(route$sequence, depot_idx)
      route$arrival_times <- c(route$arrival_times, route$total_time)
      route$service_times <- c(route$service_times, route$total_time)
    }
    
    routes[[length(routes) + 1]] <- route
  }
  
  return(list(routes = routes))
}

#' Greedy Algorithm (best insertion)
#' 
#' @param problem A problem instance
#' 
#' @return A solution with routes
solve_greedy <- function(problem) {
  routes <- list()
  unvisited_customers <- 1:nrow(problem$customers)
  
  for (v in 1:nrow(problem$vehicles)) {
    vehicle <- problem$vehicles[v, ]
    depot_idx <- vehicle$depot_id
    
    route <- list(
      vehicle_id = vehicle$vehicle_id,
      depot_id = vehicle$depot_id,
      sequence = c(depot_idx, depot_idx),  # Start and end at depot
      arrival_times = c(0, 0),
      service_times = c(0, 0),
      total_distance = 0,
      total_time = 0,
      load = 0
    )
    
    while (length(unvisited_customers) > 0) {
      best_customer <- NULL
      best_position <- NULL
      best_cost_increase <- Inf
      
      for (cust_idx in unvisited_customers) {
        customer <- problem$customers[cust_idx, ]
        
        # Check capacity constraint
        if (customer$demand > (vehicle$capacity - route$load)) next
        
        # Try inserting at each position in the route
        for (pos in 2:length(route$sequence)) {
          cost_increase <- calculate_insertion_cost(problem, route, cust_idx, pos, vehicle)
          
          if (cost_increase < best_cost_increase) {
            best_cost_increase <- cost_increase
            best_customer <- cust_idx
            best_position <- pos
          }
        }
      }
      
      if (is.null(best_customer)) break
      
      # Insert the best customer
      route <- insert_customer_in_route(problem, route, best_customer, best_position, vehicle)
      unvisited_customers <- unvisited_customers[unvisited_customers != best_customer]
    }
    
    if (length(route$sequence) > 2) {  # Only add routes with customers
      routes[[length(routes) + 1]] <- route
    }
  }
  
  return(list(routes = routes))
}

#' Simulated Annealing Algorithm
#' 
#' @param problem A problem instance
#' @param max_iterations Maximum number of iterations
#' 
#' @return A solution with routes
solve_simulated_annealing <- function(problem, max_iterations = 1000) {
  # Start with greedy solution
  current_solution <- solve_greedy(problem)
  best_solution <- current_solution
  current_cost <- calculate_total_cost(problem, current_solution$routes)
  best_cost <- current_cost
  
  # SA parameters
  initial_temp <- current_cost * 0.1
  final_temp <- 0.01
  cooling_rate <- (initial_temp / final_temp)^(1 / max_iterations)
  temperature <- initial_temp
  
  for (iter in 1:max_iterations) {
    # Generate neighbor solution
    neighbor_solution <- generate_neighbor_solution(problem, current_solution)
    neighbor_cost <- calculate_total_cost(problem, neighbor_solution$routes)
    
    # Accept or reject the neighbor
    if (neighbor_cost < current_cost || runif(1) < exp(-(neighbor_cost - current_cost) / temperature)) {
      current_solution <- neighbor_solution
      current_cost <- neighbor_cost
      
      if (current_cost < best_cost) {
        best_solution <- current_solution
        best_cost <- current_cost
      }
    }
    
    # Cool down
    temperature <- temperature / cooling_rate
  }
  
  return(best_solution)
}

#' Helper function to get distance between two locations
#' 
#' @param problem Problem instance
#' @param from_idx Index of origin location
#' @param to_idx Index of destination location
#' 
#' @return Distance between locations
get_distance <- function(problem, from_idx, to_idx) {
  return(problem$distance_matrix[from_idx, to_idx])
}

#' Calculate total cost of a solution
#' 
#' @param problem Problem instance
#' @param routes List of routes
#' 
#' @return Total cost
calculate_total_cost <- function(problem, routes) {
  if (is.null(routes) || length(routes) == 0) return(Inf)
  
  total_cost <- 0
  
  for (route in routes) {
    if (length(route$sequence) <= 2) next  # Skip empty routes
    
    vehicle <- problem$vehicles[problem$vehicles$vehicle_id == route$vehicle_id, ]
    
    # Fixed cost for using the vehicle
    total_cost <- total_cost + vehicle$fixed_cost
    
    # Variable cost based on distance
    total_cost <- total_cost + route$total_distance * vehicle$variable_cost
  }
  
  return(total_cost)
}

#' Calculate cost increase for inserting a customer at a specific position
#' 
#' @param problem Problem instance
#' @param route Current route
#' @param customer_idx Customer to insert
#' @param position Position to insert at
#' @param vehicle Vehicle information
#' 
#' @return Cost increase
calculate_insertion_cost <- function(problem, route, customer_idx, position, vehicle) {
  if (position < 2 || position > length(route$sequence)) return(Inf)
  
  customer <- problem$customers[customer_idx, ]
  customer_location_idx <- customer_idx + nrow(problem$depots)
  
  prev_location <- route$sequence[position - 1]
  next_location <- route$sequence[position]
  
  # Calculate distance changes
  old_distance <- get_distance(problem, prev_location, next_location)
  new_distance <- get_distance(problem, prev_location, customer_location_idx) +
                  get_distance(problem, customer_location_idx, next_location)
  
  distance_increase <- new_distance - old_distance
  
  # Simple cost calculation (can be extended with time window penalties)
  return(distance_increase * vehicle$variable_cost)
}

#' Insert a customer into a route at a specific position
#' 
#' @param problem Problem instance
#' @param route Current route
#' @param customer_idx Customer to insert
#' @param position Position to insert at
#' @param vehicle Vehicle information
#' 
#' @return Updated route
insert_customer_in_route <- function(problem, route, customer_idx, position, vehicle) {
  customer <- problem$customers[customer_idx, ]
  customer_location_idx <- customer_idx + nrow(problem$depots)
  
  # Insert customer in sequence
  route$sequence <- append(route$sequence, customer_location_idx, after = position - 1)
  
  # Recalculate route metrics
  route <- recalculate_route_metrics(problem, route, vehicle)
  
  return(route)
}

#' Recalculate route metrics after modification
#' 
#' @param problem Problem instance
#' @param route Route to recalculate
#' @param vehicle Vehicle information
#' 
#' @return Updated route with recalculated metrics
recalculate_route_metrics <- function(problem, route, vehicle) {
  if (length(route$sequence) < 2) return(route)
  
  route$arrival_times <- numeric(length(route$sequence))
  route$service_times <- numeric(length(route$sequence))
  route$total_distance <- 0
  route$load <- 0
  current_time <- 0
  
  for (i in 1:length(route$sequence)) {
    location_idx <- route$sequence[i]
    
    if (i > 1) {
      prev_location <- route$sequence[i - 1]
      distance <- get_distance(problem, prev_location, location_idx)
      travel_time <- distance / vehicle$speed
      current_time <- current_time + travel_time
      route$total_distance <- route$total_distance + distance
    }
    
    route$arrival_times[i] <- current_time
    
    # If it's a customer (not depot)
    if (location_idx > nrow(problem$depots)) {
      customer_idx <- location_idx - nrow(problem$depots)
      customer <- problem$customers[customer_idx, ]
      
      service_start <- max(current_time, customer$early_time)
      current_time <- service_start + customer$service_time
      route$load <- route$load + customer$demand
      route$service_times[i] <- service_start
    } else {
      route$service_times[i] <- current_time
    }
  }
  
  route$total_time <- current_time
  return(route)
}

#' Generate a neighbor solution for simulated annealing
#' 
#' @param problem Problem instance
#' @param solution Current solution
#' 
#' @return Neighbor solution
generate_neighbor_solution <- function(problem, solution) {
  neighbor <- solution
  
  if (length(neighbor$routes) == 0) return(neighbor)
  
  # Randomly choose a neighborhood operation
  operation <- sample(c("swap", "relocate", "2opt"), 1)
  
  if (operation == "swap" && length(neighbor$routes) >= 2) {
    # Swap customers between two routes
    route1_idx <- sample(1:length(neighbor$routes), 1)
    route2_idx <- sample((1:length(neighbor$routes))[-route1_idx], 1)
    
    route1 <- neighbor$routes[[route1_idx]]
    route2 <- neighbor$routes[[route2_idx]]
    
    if (length(route1$sequence) > 2 && length(route2$sequence) > 2) {
      # Swap random customers (excluding depot positions)
      pos1 <- sample(2:(length(route1$sequence) - 1), 1)
      pos2 <- sample(2:(length(route2$sequence) - 1), 1)
      
      temp <- route1$sequence[pos1]
      route1$sequence[pos1] <- route2$sequence[pos2]
      route2$sequence[pos2] <- temp
      
      # Recalculate metrics
      vehicle1 <- problem$vehicles[problem$vehicles$vehicle_id == route1$vehicle_id, ]
      vehicle2 <- problem$vehicles[problem$vehicles$vehicle_id == route2$vehicle_id, ]
      
      neighbor$routes[[route1_idx]] <- recalculate_route_metrics(problem, route1, vehicle1)
      neighbor$routes[[route2_idx]] <- recalculate_route_metrics(problem, route2, vehicle2)
    }
  }
  
  return(neighbor)
}

#' Validate if a solution is feasible
#' 
#' @param problem Problem instance
#' @param solution Solution to validate
#' 
#' @return TRUE if feasible, FALSE otherwise
validate_solution <- function(problem, solution) {
  if (is.null(solution$routes)) return(FALSE)
  
  visited_customers <- c()
  
  for (route in solution$routes) {
    vehicle <- problem$vehicles[problem$vehicles$vehicle_id == route$vehicle_id, ]
    
    # Check capacity constraint
    if (route$load > vehicle$capacity) return(FALSE)
    
    # Check time windows
    for (i in 2:(length(route$sequence) - 1)) {
      location_idx <- route$sequence[i]
      if (location_idx > nrow(problem$depots)) {
        customer_idx <- location_idx - nrow(problem$depots)
        customer <- problem$customers[customer_idx, ]
        
        if (route$service_times[i] < customer$early_time || 
            route$service_times[i] > customer$late_time) {
          return(FALSE)
        }
        
        visited_customers <- c(visited_customers, customer_idx)
      }
    }
  }
  
  # Check if all customers are visited (for complete solutions)
  all_customers <- 1:nrow(problem$customers)
  if (length(setdiff(all_customers, visited_customers)) > 0) {
    # Partial solution is acceptable
  }
  
  return(TRUE)
}